<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnostic HTTPS - Synchronisation</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3a8a 0%, #1a237e 50%, #0d1b2a 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #d97706;
        }
        .logo {
            color: #d97706;
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
            border-left: 4px solid;
        }
        .status.success { 
            background: rgba(34, 197, 94, 0.1); 
            color: #22c55e; 
            border-left-color: #22c55e; 
        }
        .status.warning { 
            background: rgba(245, 158, 11, 0.1); 
            color: #f59e0b; 
            border-left-color: #f59e0b; 
        }
        .status.error { 
            background: rgba(239, 68, 68, 0.1); 
            color: #ef4444; 
            border-left-color: #ef4444; 
        }
        .status.info { 
            background: rgba(59, 130, 246, 0.1); 
            color: #3b82f6; 
            border-left-color: #3b82f6; 
        }
        .test-section {
            margin: 25px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .test-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .test-title::before {
            content: "üîç";
            margin-right: 10px;
        }
        .btn {
            background: #d97706;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin: 5px;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .btn:hover { 
            background: #b45309; 
            transform: translateY(-2px);
        }
        .btn.secondary {
            background: #6b7280;
        }
        .btn.secondary:hover { 
            background: #4b5563; 
        }
        .btn.danger {
            background: #ef4444;
        }
        .btn.danger:hover { 
            background: #dc2626; 
        }
        .results {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 5px;
        }
        .metric-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">DIAGNOSTIC HTTPS</h1>
            <h2>Analyse de Synchronisation Temps R√©el</h2>
            <p>Outil de diagnostic pour r√©soudre les probl√®mes de collaboration HTTPS</p>
        </div>

        <!-- M√©triques de base -->
        <div class="test-section">
            <div class="test-title">√âtat HTTPS et S√©curit√©</div>
            <div class="grid">
                <div class="metric">
                    <div class="metric-value" id="https-status">‚ùì</div>
                    <div class="metric-label">Protocole HTTPS</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="ssl-status">‚ùì</div>
                    <div class="metric-label">Certificat SSL</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="mixed-content">‚ùì</div>
                    <div class="metric-label">Contenu Mixte</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="websocket-status">‚ùì</div>
                    <div class="metric-label">WebSocket S√©curis√©</div>
                </div>
            </div>
            <button class="btn" onclick="checkHTTPSStatus()">üîí V√©rifier HTTPS</button>
        </div>

        <!-- Test de synchronisation -->
        <div class="test-section">
            <div class="test-title">Test de Synchronisation</div>
            <div id="sync-results"></div>
            <div class="grid">
                <button class="btn" onclick="testSupabaseConnection()">üóÑÔ∏è Test Supabase</button>
                <button class="btn" onclick="testRealtimeChannel()">üì° Test Canal Temps R√©el</button>
                <button class="btn" onclick="testContentSync()">üìù Test Sync Contenu</button>
                <button class="btn" onclick="testCrossDeviceSync()">üì± Test Multi-Appareils</button>
            </div>
        </div>

        <!-- Diagnostic des ressources -->
        <div class="test-section">
            <div class="test-title">Ressources et Cache</div>
            <div id="resources-results"></div>
            <div class="grid">
                <button class="btn" onclick="checkMixedContent()">üîç Contenu Mixte</button>
                <button class="btn" onclick="analyzeCacheHeaders()">üíæ Headers Cache</button>
                <button class="btn" onclick="testImageLoading()">üñºÔ∏è Test Images</button>
                <button class="btn secondary" onclick="clearAllCaches()">üßπ Vider Caches</button>
            </div>
        </div>

        <!-- Solutions automatiques -->
        <div class="test-section">
            <div class="test-title">Solutions Automatiques</div>
            <div id="solutions-results"></div>
            <div class="grid">
                <button class="btn" onclick="fixMixedContent()">üîß Corriger Contenu Mixte</button>
                <button class="btn" onclick="forceHTTPSRedirect()">üîÑ Forcer HTTPS</button>
                <button class="btn" onclick="updateServiceWorker()">‚öôÔ∏è Mettre √† Jour SW</button>
                <button class="btn danger" onclick="emergencyHTTPSFix()">üö® Correction d'Urgence</button>
            </div>
        </div>

        <!-- Monitoring temps r√©el -->
        <div class="test-section">
            <div class="test-title">Monitoring Temps R√©el</div>
            <div id="monitoring-results">
                <div class="status info">üîÑ Monitoring en attente...</div>
            </div>
            <button class="btn" onclick="startRealtimeMonitoring()">üìä D√©marrer Monitoring</button>
            <button class="btn secondary" onclick="stopRealtimeMonitoring()">‚èπÔ∏è Arr√™ter</button>
        </div>
    </div>

    <script>
        // Variables globales pour le diagnostic
        let diagnosticData = {
            httpsIssues: [],
            syncProblems: [],
            solutions: [],
            timestamp: new Date().toISOString()
        };

        let monitoringInterval = null;

        // 1. V√©rification HTTPS et s√©curit√©
        async function checkHTTPSStatus() {
            try {
                const httpsStatus = document.getElementById('https-status');
                const sslStatus = document.getElementById('ssl-status');
                const mixedContent = document.getElementById('mixed-content');
                const websocketStatus = document.getElementById('websocket-status');

                // Test HTTPS
                const isHTTPS = location.protocol === 'https:';
                httpsStatus.textContent = isHTTPS ? '‚úÖ' : '‚ùå';
                httpsStatus.style.color = isHTTPS ? '#22c55e' : '#ef4444';

                // Test certificat SSL
                try {
                    const response = await fetch(location.origin, { method: 'HEAD' });
                    sslStatus.textContent = response.ok ? '‚úÖ' : '‚ö†Ô∏è';
                    sslStatus.style.color = response.ok ? '#22c55e' : '#f59e0b';
                } catch (error) {
                    sslStatus.textContent = '‚ùå';
                    sslStatus.style.color = '#ef4444';
                }

                // Test contenu mixte
                const mixedContentIssues = checkForMixedContent();
                mixedContent.textContent = mixedContentIssues.length === 0 ? '‚úÖ' : '‚ùå';
                mixedContent.style.color = mixedContentIssues.length === 0 ? '#22c55e' : '#ef4444';

                // Test WebSocket s√©curis√©
                const wsProtocol = isHTTPS ? 'wss:' : 'ws:';
                websocketStatus.textContent = isHTTPS ? '‚úÖ' : '‚ùå';
                websocketStatus.style.color = isHTTPS ? '#22c55e' : '#ef4444';

                console.log('HTTPS Status Check Complete');

            } catch (error) {
                console.error('Erreur v√©rification HTTPS:', error);
            }
        }

        // 2. Test connexion Supabase
        async function testSupabaseConnection() {
            const resultsDiv = document.getElementById('sync-results');
            resultsDiv.innerHTML = '<div class="status info">üîÑ Test de connexion Supabase...</div>';

            try {
                // V√©rifier les variables d'environnement
                const supabaseUrl = 'https://your-project.supabase.co'; // √Ä remplacer
                const supabaseKey = 'your-anon-key'; // √Ä remplacer

                let html = '';

                if (supabaseUrl === 'https://your-project.supabase.co') {
                    html += '<div class="status error">‚ùå Supabase non configur√© - Variables d\'environnement manquantes</div>';
                    html += '<div class="status info">üí° Solution: Cliquez sur "Connect to Supabase" en haut √† droite</div>';
                } else {
                    // Test de connexion HTTPS
                    try {
                        const response = await fetch(`${supabaseUrl}/rest/v1/`, {
                            headers: {
                                'apikey': supabaseKey,
                                'Authorization': `Bearer ${supabaseKey}`
                            }
                        });

                        if (response.ok) {
                            html += '<div class="status success">‚úÖ Connexion Supabase HTTPS r√©ussie</div>';
                            
                            // Test des tables
                            const tablesResponse = await fetch(`${supabaseUrl}/rest/v1/user_registrations?select=count`, {
                                headers: {
                                    'apikey': supabaseKey,
                                    'Authorization': `Bearer ${supabaseKey}`
                                }
                            });
                            
                            if (tablesResponse.ok) {
                                html += '<div class="status success">‚úÖ Tables de base de donn√©es accessibles</div>';
                            } else {
                                html += '<div class="status warning">‚ö†Ô∏è Probl√®me d\'acc√®s aux tables</div>';
                            }
                        } else {
                            html += `<div class="status error">‚ùå Erreur connexion Supabase: ${response.status}</div>';
                        }
                    } catch (error) {
                        html += `<div class="status error">‚ùå Impossible de se connecter √† Supabase: ${error.message}</div>';
                        html += '<div class="status info">üí° V√©rifiez que l\'URL Supabase est en HTTPS</div>';
                    }
                }

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur test Supabase: ${error.message}</div>`;
            }
        }

        // 3. Test canal temps r√©el
        async function testRealtimeChannel() {
            const resultsDiv = document.getElementById('sync-results');
            const currentContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = currentContent + '<div class="status info">üîÑ Test du canal temps r√©el...</div>';

            try {
                let html = '';

                // V√©rifier WebSocket s√©curis√©
                const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                html += `<div class="status info">üì° Protocole WebSocket: ${wsProtocol}</div>`;

                if (wsProtocol === 'ws:') {
                    html += '<div class="status error">‚ùå WebSocket non s√©curis√© - Bloqu√© par HTTPS</div>';
                    html += '<div class="status info">üí° Solution: Configurer WSS (WebSocket Secure)</div>';
                } else {
                    html += '<div class="status success">‚úÖ WebSocket s√©curis√© (WSS)</div>';
                    
                    // Test de connexion WebSocket
                    try {
                        const testWS = new WebSocket('wss://echo.websocket.org');
                        
                        testWS.onopen = () => {
                            html += '<div class="status success">‚úÖ Connexion WebSocket fonctionnelle</div>';
                            resultsDiv.innerHTML = currentContent + html;
                            testWS.close();
                        };
                        
                        testWS.onerror = () => {
                            html += '<div class="status error">‚ùå Erreur connexion WebSocket</div>';
                            resultsDiv.innerHTML = currentContent + html;
                        };
                        
                        // Timeout apr√®s 5 secondes
                        setTimeout(() => {
                            if (testWS.readyState === WebSocket.CONNECTING) {
                                testWS.close();
                                html += '<div class="status warning">‚ö†Ô∏è Timeout connexion WebSocket</div>';
                                resultsDiv.innerHTML = currentContent + html;
                            }
                        }, 5000);
                        
                    } catch (error) {
                        html += `<div class="status error">‚ùå Erreur WebSocket: ${error.message}</div>`;
                    }
                }

                resultsDiv.innerHTML = currentContent + html;

            } catch (error) {
                resultsDiv.innerHTML = currentContent + `<div class="status error">‚ùå Erreur test canal: ${error.message}</div>`;
            }
        }

        // 4. Test synchronisation contenu
        async function testContentSync() {
            const resultsDiv = document.getElementById('sync-results');
            const currentContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = currentContent + '<div class="status info">üîÑ Test synchronisation contenu...</div>';

            try {
                let html = '';

                // Test localStorage
                try {
                    const testData = { test: 'sync', timestamp: Date.now() };
                    localStorage.setItem('sync-test', JSON.stringify(testData));
                    const retrieved = localStorage.getItem('sync-test');
                    
                    if (retrieved && JSON.parse(retrieved).test === 'sync') {
                        html += '<div class="status success">‚úÖ LocalStorage fonctionnel</div>';
                    } else {
                        html += '<div class="status error">‚ùå Probl√®me localStorage</div>';
                    }
                    localStorage.removeItem('sync-test');
                } catch (error) {
                    html += '<div class="status error">‚ùå LocalStorage non accessible</div>';
                }

                // Test Service Worker
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.getRegistration();
                        if (registration) {
                            html += '<div class="status success">‚úÖ Service Worker actif</div>';
                            
                            // V√©rifier si le SW utilise HTTPS
                            if (registration.scope.startsWith('https://')) {
                                html += '<div class="status success">‚úÖ Service Worker s√©curis√© (HTTPS)</div>';
                            } else {
                                html += '<div class="status warning">‚ö†Ô∏è Service Worker non s√©curis√©</div>';
                            }
                        } else {
                            html += '<div class="status warning">‚ö†Ô∏è Aucun Service Worker enregistr√©</div>';
                        }
                    } catch (error) {
                        html += '<div class="status error">‚ùå Erreur Service Worker</div>';
                    }
                } else {
                    html += '<div class="status error">‚ùå Service Worker non support√©</div>';
                }

                // Test des √©v√©nements personnalis√©s
                let eventReceived = false;
                const testEvent = () => {
                    eventReceived = true;
                };
                
                window.addEventListener('test-sync-event', testEvent);
                window.dispatchEvent(new CustomEvent('test-sync-event'));
                
                setTimeout(() => {
                    if (eventReceived) {
                        html += '<div class="status success">‚úÖ √âv√©nements personnalis√©s fonctionnels</div>';
                    } else {
                        html += '<div class="status error">‚ùå Probl√®me √©v√©nements personnalis√©s</div>';
                    }
                    
                    window.removeEventListener('test-sync-event', testEvent);
                    resultsDiv.innerHTML = currentContent + html;
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = currentContent + `<div class="status error">‚ùå Erreur test sync: ${error.message}</div>`;
            }
        }

        // 5. Test multi-appareils
        async function testCrossDeviceSync() {
            const resultsDiv = document.getElementById('sync-results');
            const currentContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = currentContent + '<div class="status info">üîÑ Test synchronisation multi-appareils...</div>';

            try {
                let html = '';

                // G√©n√©rer un ID de test unique
                const testId = 'sync-test-' + Date.now();
                const testData = {
                    id: testId,
                    content: 'Test de synchronisation',
                    timestamp: new Date().toISOString(),
                    device: navigator.userAgent.split(' ')[0]
                };

                // Sauvegarder localement
                localStorage.setItem('cross-device-test', JSON.stringify(testData));
                html += '<div class="status success">‚úÖ Donn√©es de test sauvegard√©es localement</div>';

                // Simuler une modification collaborative
                html += '<div class="status info">üì± Simulation modification collaborative...</div>';
                
                // Test de diffusion d'√©v√©nement
                window.dispatchEvent(new CustomEvent('contentUpdated', { 
                    detail: testData 
                }));
                
                html += '<div class="status success">‚úÖ √âv√©nement de synchronisation diffus√©</div>';

                // Instructions pour test manuel
                html += '<div class="status info">üìã Pour tester compl√®tement:</div>';
                html += '<div class="results">1. Ouvrez ce site sur un autre appareil/navigateur\n';
                html += '2. Connectez-vous en admin\n';
                html += '3. Modifiez un bien immobilier\n';
                html += '4. Cliquez "PUBLIER POUR TOUS"\n';
                html += '5. V√©rifiez que ce navigateur se met √† jour automatiquement</div>';

                resultsDiv.innerHTML = currentContent + html;

            } catch (error) {
                resultsDiv.innerHTML = currentContent + `<div class="status error">‚ùå Erreur test multi-appareils: ${error.message}</div>`;
            }
        }

        // 6. V√©rifier le contenu mixte
        function checkForMixedContent() {
            const issues = [];
            
            // V√©rifier les images
            const images = document.querySelectorAll('img');
            images.forEach(img => {
                if (img.src && img.src.startsWith('http://')) {
                    issues.push(`Image HTTP: ${img.src}`);
                }
            });
            
            // V√©rifier les scripts
            const scripts = document.querySelectorAll('script[src]');
            scripts.forEach(script => {
                if (script.src && script.src.startsWith('http://')) {
                    issues.push(`Script HTTP: ${script.src}`);
                }
            });
            
            // V√©rifier les CSS
            const stylesheets = document.querySelectorAll('link[rel="stylesheet"]');
            stylesheets.forEach(link => {
                if (link.href && link.href.startsWith('http://')) {
                    issues.push(`CSS HTTP: ${link.href}`);
                }
            });
            
            return issues;
        }

        function checkMixedContent() {
            const resultsDiv = document.getElementById('resources-results');
            resultsDiv.innerHTML = '<div class="status info">üîÑ Analyse du contenu mixte...</div>';

            try {
                const issues = checkForMixedContent();
                let html = '';

                if (issues.length === 0) {
                    html += '<div class="status success">‚úÖ Aucun contenu mixte d√©tect√©</div>';
                } else {
                    html += `<div class="status error">‚ùå ${issues.length} probl√®me(s) de contenu mixte d√©tect√©(s)</div>`;
                    html += '<div class="results">Ressources HTTP d√©tect√©es:\n' + issues.join('\n') + '</div>';
                    html += '<div class="status info">üí° Solution: Convertir toutes les URLs en HTTPS</div>';
                }

                // V√©rifier les fetch/XHR
                const originalFetch = window.fetch;
                let httpRequests = [];
                
                window.fetch = function(...args) {
                    const url = args[0];
                    if (typeof url === 'string' && url.startsWith('http://')) {
                        httpRequests.push(url);
                    }
                    return originalFetch.apply(this, args);
                };

                // Restaurer fetch apr√®s 1 seconde
                setTimeout(() => {
                    window.fetch = originalFetch;
                    if (httpRequests.length > 0) {
                        html += `<div class="status warning">‚ö†Ô∏è ${httpRequests.length} requ√™te(s) HTTP d√©tect√©e(s)</div>`;
                    }
                }, 1000);

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur analyse contenu mixte: ${error.message}</div>`;
            }
        }

        // 7. Analyser les headers de cache
        async function analyzeCacheHeaders() {
            const resultsDiv = document.getElementById('resources-results');
            const currentContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = currentContent + '<div class="status info">üîÑ Analyse des headers de cache...</div>';

            try {
                let html = '';

                // Test des headers de cache
                const response = await fetch(location.href, { method: 'HEAD' });
                const headers = response.headers;

                // V√©rifier les headers de s√©curit√© HTTPS
                const securityHeaders = [
                    'strict-transport-security',
                    'content-security-policy',
                    'x-frame-options',
                    'x-content-type-options'
                ];

                securityHeaders.forEach(header => {
                    const value = headers.get(header);
                    if (value) {
                        html += `<div class="status success">‚úÖ ${header}: ${value.substring(0, 50)}...</div>`;
                    } else {
                        html += `<div class="status warning">‚ö†Ô∏è Header manquant: ${header}</div>`;
                    }
                });

                // V√©rifier les headers de cache
                const cacheControl = headers.get('cache-control');
                if (cacheControl) {
                    html += `<div class="status info">üíæ Cache-Control: ${cacheControl}</div>`;
                } else {
                    html += '<div class="status warning">‚ö†Ô∏è Pas de Cache-Control d√©fini</div>';
                }

                resultsDiv.innerHTML = currentContent + html;

            } catch (error) {
                resultsDiv.innerHTML = currentContent + `<div class="status error">‚ùå Erreur analyse headers: ${error.message}</div>`;
            }
        }

        // 8. Test chargement images
        async function testImageLoading() {
            const resultsDiv = document.getElementById('resources-results');
            const currentContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = currentContent + '<div class="status info">üîÑ Test chargement images...</div>';

            try {
                let html = '';

                // Test images Pexels (utilis√©es dans le site)
                const testImages = [
                    'https://images.pexels.com/photos/1396122/pexels-photo-1396122.jpeg?auto=compress&cs=tinysrgb&w=100',
                    'https://images.pexels.com/photos/1115804/pexels-photo-1115804.jpeg?auto=compress&cs=tinysrgb&w=100'
                ];

                for (const imageUrl of testImages) {
                    try {
                        const response = await fetch(imageUrl, { method: 'HEAD' });
                        if (response.ok) {
                            html += `<div class="status success">‚úÖ Image Pexels accessible (${response.status})</div>`;
                        } else {
                            html += `<div class="status warning">‚ö†Ô∏è Probl√®me image Pexels: ${response.status}</div>`;
                        }
                    } catch (error) {
                        html += `<div class="status error">‚ùå Image Pexels inaccessible: ${error.message}</div>`;
                    }
                }

                // Test CORS
                html += '<div class="status info">üåê Test CORS pour images externes...</div>';
                
                resultsDiv.innerHTML = currentContent + html;

            } catch (error) {
                resultsDiv.innerHTML = currentContent + `<div class="status error">‚ùå Erreur test images: ${error.message}</div>`;
            }
        }

        // 9. Corriger le contenu mixte
        function fixMixedContent() {
            const resultsDiv = document.getElementById('solutions-results');
            resultsDiv.innerHTML = '<div class="status info">üîß Correction du contenu mixte...</div>';

            try {
                let fixes = [];
                let html = '';

                // Corriger les images HTTP
                const images = document.querySelectorAll('img[src^="http://"]');
                images.forEach(img => {
                    const httpsUrl = img.src.replace('http://', 'https://');
                    img.src = httpsUrl;
                    fixes.push(`Image corrig√©e: ${httpsUrl}`);
                });

                // Corriger les liens HTTP
                const links = document.querySelectorAll('a[href^="http://"]');
                links.forEach(link => {
                    const httpsUrl = link.href.replace('http://', 'https://');
                    link.href = httpsUrl;
                    fixes.push(`Lien corrig√©: ${httpsUrl}`);
                });

                // Mettre √† jour localStorage avec URLs HTTPS
                const storageKeys = ['siteContent', 'properties', 'presentationImages'];
                storageKeys.forEach(key => {
                    try {
                        const data = localStorage.getItem(key);
                        if (data) {
                            const parsed = JSON.parse(data);
                            const updated = JSON.stringify(parsed).replace(/http:\/\//g, 'https://');
                            if (updated !== data) {
                                localStorage.setItem(key, updated);
                                fixes.push(`LocalStorage ${key} mis √† jour vers HTTPS`);
                            }
                        }
                    } catch (error) {
                        console.warn(`Erreur mise √† jour ${key}:`, error);
                    }
                });

                if (fixes.length === 0) {
                    html = '<div class="status success">‚úÖ Aucun contenu mixte √† corriger</div>';
                } else {
                    html = `<div class="status success">‚úÖ ${fixes.length} correction(s) appliqu√©e(s)</div>`;
                    html += '<div class="results">' + fixes.join('\n') + '</div>';
                }

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur correction contenu mixte: ${error.message}</div>`;
            }
        }

        // 10. Forcer redirection HTTPS
        function forceHTTPSRedirect() {
            const resultsDiv = document.getElementById('solutions-results');
            
            if (location.protocol === 'http:') {
                resultsDiv.innerHTML = '<div class="status info">üîÑ Redirection vers HTTPS...</div>';
                setTimeout(() => {
                    location.href = location.href.replace('http://', 'https://');
                }, 1000);
            } else {
                resultsDiv.innerHTML = '<div class="status success">‚úÖ D√©j√† en HTTPS</div>';
            }
        }

        // 11. Mettre √† jour Service Worker
        async function updateServiceWorker() {
            const resultsDiv = document.getElementById('solutions-results');
            resultsDiv.innerHTML = '<div class="status info">üîÑ Mise √† jour Service Worker...</div>';

            try {
                let html = '';

                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    
                    if (registrations.length > 0) {
                        for (const registration of registrations) {
                            await registration.update();
                            html += '<div class="status success">‚úÖ Service Worker mis √† jour</div>';
                        }
                        
                        // Vider les caches
                        if ('caches' in window) {
                            const cacheNames = await caches.keys();
                            for (const cacheName of cacheNames) {
                                await caches.delete(cacheName);
                            }
                            html += `<div class="status success">‚úÖ ${cacheNames.length} cache(s) vid√©(s)</div>`;
                        }
                        
                        html += '<div class="status info">üîÑ Rechargement recommand√©</div>';
                    } else {
                        html += '<div class="status warning">‚ö†Ô∏è Aucun Service Worker √† mettre √† jour</div>';
                    }
                } else {
                    html += '<div class="status error">‚ùå Service Worker non support√©</div>';
                }

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur mise √† jour SW: ${error.message}</div>`;
            }
        }

        // 12. Correction d'urgence HTTPS
        function emergencyHTTPSFix() {
            if (!confirm('üö® CORRECTION D\'URGENCE HTTPS üö®\n\nCette action va :\n- Forcer HTTPS sur toutes les ressources\n- Vider tous les caches\n- Recharger la page\n\nContinuer ?')) {
                return;
            }

            const resultsDiv = document.getElementById('solutions-results');
            resultsDiv.innerHTML = '<div class="status error">üö® Correction d\'urgence HTTPS...</div>';

            try {
                // 1. Corriger toutes les URLs HTTP
                fixMixedContent();
                
                // 2. Forcer HTTPS dans localStorage
                Object.keys(localStorage).forEach(key => {
                    try {
                        const value = localStorage.getItem(key);
                        if (value && value.includes('http://')) {
                            const httpsValue = value.replace(/http:\/\//g, 'https://');
                            localStorage.setItem(key, httpsValue);
                        }
                    } catch (error) {
                        console.warn(`Erreur correction ${key}:`, error);
                    }
                });

                // 3. Vider tous les caches
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => caches.delete(name));
                    });
                }

                // 4. Mettre √† jour Service Worker
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.getRegistrations().then(registrations => {
                        registrations.forEach(registration => registration.update());
                    });
                }

                resultsDiv.innerHTML = '<div class="status success">‚úÖ Correction d\'urgence appliqu√©e - Rechargement...</div>';
                
                // 5. Recharger avec HTTPS forc√©
                setTimeout(() => {
                    const httpsUrl = location.href.replace('http://', 'https://');
                    location.href = httpsUrl + '?https-fixed=' + Date.now();
                }, 2000);

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur correction urgence: ${error.message}</div>`;
            }
        }

        // 13. Monitoring temps r√©el
        function startRealtimeMonitoring() {
            const resultsDiv = document.getElementById('monitoring-results');
            
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }

            resultsDiv.innerHTML = '<div class="status success">üìä Monitoring temps r√©el d√©marr√©...</div>';

            let eventCount = 0;
            let lastUpdate = Date.now();

            // √âcouter tous les √©v√©nements de synchronisation
            const events = ['contentUpdated', 'storage', 'presentationImageChanged', 'designSettingsChanged', 'forceUpdate'];
            
            events.forEach(eventName => {
                window.addEventListener(eventName, (event) => {
                    eventCount++;
                    lastUpdate = Date.now();
                    
                    const html = `
                        <div class="status success">üì° √âv√©nement d√©tect√©: ${eventName}</div>
                        <div class="results">√âv√©nements re√ßus: ${eventCount}
Dernier √©v√©nement: ${new Date(lastUpdate).toLocaleTimeString()}
Type: ${eventName}
D√©tails: ${event.detail ? JSON.stringify(event.detail, null, 2) : 'Aucun d√©tail'}</div>
                    `;
                    resultsDiv.innerHTML = html;
                });
            });

            // Monitoring p√©riodique
            monitoringInterval = setInterval(() => {
                const timeSinceLastUpdate = Date.now() - lastUpdate;
                const status = timeSinceLastUpdate > 30000 ? 'warning' : 'success';
                const icon = timeSinceLastUpdate > 30000 ? '‚ö†Ô∏è' : '‚úÖ';
                
                const html = `
                    <div class="status ${status}">${icon} Monitoring actif - ${eventCount} √©v√©nement(s)</div>
                    <div class="results">Derni√®re activit√©: ${Math.round(timeSinceLastUpdate / 1000)}s
√âtat: ${timeSinceLastUpdate > 30000 ? 'Inactif' : 'Actif'}
Protocole: ${location.protocol}
WebSocket: ${location.protocol === 'https:' ? 'WSS (S√©curis√©)' : 'WS (Non s√©curis√©)'}</div>
                `;
                resultsDiv.innerHTML = html;
            }, 5000);
        }

        function stopRealtimeMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }
            
            document.getElementById('monitoring-results').innerHTML = 
                '<div class="status info">‚èπÔ∏è Monitoring arr√™t√©</div>';
        }

        // 14. Vider tous les caches
        async function clearAllCaches() {
            const resultsDiv = document.getElementById('resources-results');
            resultsDiv.innerHTML = '<div class="status info">üßπ Nettoyage des caches...</div>';

            try {
                let html = '';

                // Vider localStorage (sauf donn√©es importantes)
                const importantKeys = ['userLoggedIn', 'userData', 'adminLoggedIn'];
                const keysToSave = {};
                
                importantKeys.forEach(key => {
                    const value = localStorage.getItem(key);
                    if (value) keysToSave[key] = value;
                });

                localStorage.clear();
                
                Object.entries(keysToSave).forEach(([key, value]) => {
                    localStorage.setItem(key, value);
                });

                html += '<div class="status success">‚úÖ LocalStorage nettoy√© (session pr√©serv√©e)</div>';

                // Vider sessionStorage
                sessionStorage.clear();
                html += '<div class="status success">‚úÖ SessionStorage vid√©</div>';

                // Vider caches Service Worker
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    for (const cacheName of cacheNames) {
                        await caches.delete(cacheName);
                    }
                    html += `<div class="status success">‚úÖ ${cacheNames.length} cache(s) Service Worker vid√©(s)</div>';
                }

                html += '<div class="status success">üéâ Nettoyage termin√© - Rechargement recommand√©</div>';
                resultsDiv.innerHTML = html;

                // Proposer de recharger
                setTimeout(() => {
                    if (confirm('Nettoyage termin√©. Recharger la page maintenant ?')) {
                        location.reload();
                    }
                }, 2000);

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur nettoyage: ${error.message}</div>`;
            }
        }

        // Initialisation automatique
        window.addEventListener('load', () => {
            console.log('üîß Diagnostic HTTPS charg√©');
            checkHTTPSStatus();
            
            // Auto-diagnostic apr√®s 2 secondes
            setTimeout(() => {
                testSupabaseConnection();
            }, 2000);
        });

        // Capturer les erreurs HTTPS
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('Mixed Content')) {
                diagnosticData.httpsIssues.push({
                    type: 'mixed-content',
                    message: event.message,
                    source: event.filename,
                    timestamp: new Date().toISOString()
                });
            }
        });

        // Capturer les erreurs de s√©curit√©
        window.addEventListener('securitypolicyviolation', (event) => {
            diagnosticData.httpsIssues.push({
                type: 'csp-violation',
                directive: event.violatedDirective,
                blockedURI: event.blockedURI,
                timestamp: new Date().toISOString()
            });
        });
    </script>
</body>
</html>