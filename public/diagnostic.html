<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnostic Technique - CERCLE PRIV√â</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8fafc;
            color: #1f2937;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #d97706;
        }
        .logo {
            color: #d97706;
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }
        .status {
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 500;
        }
        .status.success { background: #dcfce7; color: #166534; border-left: 4px solid #22c55e; }
        .status.warning { background: #fef3c7; color: #92400e; border-left: 4px solid #f59e0b; }
        .status.error { background: #fee2e2; color: #991b1b; border-left: 4px solid #ef4444; }
        .status.info { background: #dbeafe; color: #1e40af; border-left: 4px solid #3b82f6; }
        .test-section {
            margin: 25px 0;
            padding: 20px;
            background: #f9fafb;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        .test-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .test-title::before {
            content: "üîç";
            margin-right: 10px;
        }
        .btn {
            background: #d97706;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            margin: 5px;
            transition: background 0.2s;
        }
        .btn:hover { background: #b45309; }
        .btn.secondary {
            background: #6b7280;
        }
        .btn.secondary:hover { background: #4b5563; }
        .btn.danger {
            background: #ef4444;
        }
        .btn.danger:hover { background: #dc2626; }
        .results {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        .progress {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: #d97706;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">CERCLE PRIV√â</h1>
            <h2>Diagnostic Technique - Page Blanche</h2>
            <p>Outil de diagnostic automatique pour identifier et r√©soudre les probl√®mes de page blanche</p>
        </div>

        <!-- √âtat g√©n√©ral -->
        <div class="test-section">
            <div class="test-title">√âtat G√©n√©ral du Site</div>
            <div id="general-status">
                <div class="status info">üîÑ Diagnostic en cours...</div>
            </div>
            <button class="btn" onclick="checkGeneralHealth()">V√©rifier l'√©tat g√©n√©ral</button>
        </div>

        <!-- Test de connectivit√© -->
        <div class="test-section">
            <div class="test-title">Connectivit√© et Ressources</div>
            <div id="connectivity-results"></div>
            <button class="btn" onclick="testConnectivity()">Tester la connectivit√©</button>
            <button class="btn secondary" onclick="testResources()">V√©rifier les ressources</button>
        </div>

        <!-- Test JavaScript -->
        <div class="test-section">
            <div class="test-title">Erreurs JavaScript</div>
            <div id="js-errors"></div>
            <button class="btn" onclick="checkJavaScriptErrors()">Analyser les erreurs JS</button>
            <button class="btn secondary" onclick="clearJSErrors()">Vider le cache JS</button>
        </div>

        <!-- Test du cache -->
        <div class="test-section">
            <div class="test-title">Cache et Stockage</div>
            <div id="cache-results"></div>
            <button class="btn" onclick="analyzeCacheHealth()">Analyser le cache</button>
            <button class="btn danger" onclick="clearAllCaches()">Vider tous les caches</button>
        </div>

        <!-- Test de performance -->
        <div class="test-section">
            <div class="test-title">Performance et Chargement</div>
            <div id="performance-results"></div>
            <button class="btn" onclick="measurePerformance()">Mesurer les performances</button>
        </div>

        <!-- Solutions automatiques -->
        <div class="test-section">
            <div class="test-title">Solutions Automatiques</div>
            <div id="auto-fix-results"></div>
            <button class="btn" onclick="runAutoFix()">üîß Correction automatique</button>
            <button class="btn danger" onclick="emergencyReset()">üö® Reset d'urgence</button>
        </div>

        <!-- Rapport final -->
        <div class="test-section">
            <div class="test-title">Rapport de Diagnostic</div>
            <div id="final-report"></div>
            <button class="btn" onclick="generateReport()">G√©n√©rer le rapport</button>
            <button class="btn secondary" onclick="exportReport()">Exporter pour support</button>
        </div>
    </div>

    <script>
        // Variables globales pour le diagnostic
        let diagnosticData = {
            errors: [],
            warnings: [],
            fixes: [],
            performance: {},
            timestamp: new Date().toISOString()
        };

        // 1. V√©rification de l'√©tat g√©n√©ral
        async function checkGeneralHealth() {
            const statusDiv = document.getElementById('general-status');
            statusDiv.innerHTML = '<div class="status info">üîÑ V√©rification en cours...</div>';

            try {
                const checks = {
                    domReady: document.readyState === 'complete',
                    reactAvailable: typeof React !== 'undefined',
                    localStorageWorking: testLocalStorage(),
                    serviceWorkerActive: await checkServiceWorker(),
                    networkOnline: navigator.onLine,
                    httpsSecure: location.protocol === 'https:'
                };

                let html = '';
                let allGood = true;

                Object.entries(checks).forEach(([key, value]) => {
                    const status = value ? 'success' : 'error';
                    const icon = value ? '‚úÖ' : '‚ùå';
                    const label = {
                        domReady: 'DOM pr√™t',
                        reactAvailable: 'React disponible',
                        localStorageWorking: 'LocalStorage fonctionnel',
                        serviceWorkerActive: 'Service Worker actif',
                        networkOnline: 'Connexion r√©seau',
                        httpsSecure: 'HTTPS s√©curis√©'
                    }[key];

                    html += `<div class="status ${status}">${icon} ${label}</div>`;
                    if (!value) allGood = false;
                });

                if (allGood) {
                    html += '<div class="status success">üéâ Tous les tests de base sont OK</div>';
                } else {
                    html += '<div class="status warning">‚ö†Ô∏è Probl√®mes d√©tect√©s - voir d√©tails ci-dessus</div>';
                }

                statusDiv.innerHTML = html;
                diagnosticData.generalHealth = checks;

            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Erreur lors du diagnostic : ${error.message}</div>`;
                diagnosticData.errors.push(`General health check: ${error.message}`);
            }
        }

        // 2. Test de connectivit√©
        async function testConnectivity() {
            const resultsDiv = document.getElementById('connectivity-results');
            resultsDiv.innerHTML = '<div class="status info">üîÑ Test de connectivit√©...</div>';

            try {
                const tests = [
                    { name: 'Site principal', url: window.location.origin },
                    { name: 'Manifest PWA', url: '/manifest.json' },
                    { name: 'Service Worker', url: '/sw.js' },
                    { name: 'Images Pexels', url: 'https://images.pexels.com/photos/1396122/pexels-photo-1396122.jpeg?auto=compress&cs=tinysrgb&w=100' }
                ];

                let html = '';
                for (const test of tests) {
                    try {
                        const start = performance.now();
                        const response = await fetch(test.url, { method: 'HEAD', cache: 'no-cache' });
                        const duration = Math.round(performance.now() - start);
                        
                        const status = response.ok ? 'success' : 'warning';
                        const icon = response.ok ? '‚úÖ' : '‚ö†Ô∏è';
                        
                        html += `<div class="status ${status}">${icon} ${test.name}: ${response.status} (${duration}ms)</div>`;
                    } catch (error) {
                        html += `<div class="status error">‚ùå ${test.name}: √âchec - ${error.message}</div>`;
                        diagnosticData.errors.push(`Connectivity ${test.name}: ${error.message}`);
                    }
                }

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur test connectivit√© : ${error.message}</div>`;
            }
        }

        // 3. Test des ressources critiques
        async function testResources() {
            const resultsDiv = document.getElementById('connectivity-results');
            const currentContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = currentContent + '<div class="status info">üîÑ V√©rification des ressources...</div>';

            const criticalResources = [
                '/icon-192.png',
                '/icon-512.png',
                '/manifest.json'
            ];

            let html = '';
            for (const resource of criticalResources) {
                try {
                    const response = await fetch(resource, { method: 'HEAD' });
                    const status = response.ok ? 'success' : 'error';
                    const icon = response.ok ? '‚úÖ' : '‚ùå';
                    html += `<div class="status ${status}">${icon} ${resource}: ${response.status}</div>`;
                } catch (error) {
                    html += `<div class="status error">‚ùå ${resource}: Non accessible</div>`;
                    diagnosticData.errors.push(`Resource ${resource}: ${error.message}`);
                }
            }

            resultsDiv.innerHTML = currentContent + html;
        }

        // 4. Analyse des erreurs JavaScript
        function checkJavaScriptErrors() {
            const resultsDiv = document.getElementById('js-errors');
            
            // R√©cup√©rer les erreurs stock√©es
            const errorLog = localStorage.getItem('errorLog');
            const errors = errorLog ? JSON.parse(errorLog) : [];

            let html = '';
            if (errors.length === 0) {
                html = '<div class="status success">‚úÖ Aucune erreur JavaScript d√©tect√©e</div>';
            } else {
                html = `<div class="status warning">‚ö†Ô∏è ${errors.length} erreur(s) JavaScript d√©tect√©e(s)</div>`;
                
                // Afficher les 5 derni√®res erreurs
                const recentErrors = errors.slice(-5);
                html += '<div class="results">';
                recentErrors.forEach((error, index) => {
                    html += `${index + 1}. ${error.message || error.reason}\n`;
                    html += `   Fichier: ${error.filename || 'N/A'}\n`;
                    html += `   Ligne: ${error.lineno || 'N/A'}\n`;
                    html += `   Date: ${new Date(error.timestamp).toLocaleString('fr-FR')}\n\n`;
                });
                html += '</div>';
            }

            resultsDiv.innerHTML = html;
            diagnosticData.jsErrors = errors;
        }

        // 5. Vider les erreurs JavaScript
        function clearJSErrors() {
            localStorage.removeItem('errorLog');
            document.getElementById('js-errors').innerHTML = '<div class="status success">‚úÖ Log d\'erreurs JavaScript vid√©</div>';
            diagnosticData.fixes.push('Cleared JavaScript error log');
        }

        // 6. Analyser la sant√© du cache
        async function analyzeCacheHealth() {
            const resultsDiv = document.getElementById('cache-results');
            resultsDiv.innerHTML = '<div class="status info">üîÑ Analyse du cache...</div>';

            try {
                let html = '';

                // LocalStorage
                const localStorageSize = JSON.stringify(localStorage).length;
                const localStorageItems = localStorage.length;
                html += `<div class="status info">üì¶ LocalStorage: ${localStorageItems} √©l√©ments (${Math.round(localStorageSize/1024)}KB)</div>`;

                // Service Worker Cache
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    html += `<div class="status info">üíæ Caches Service Worker: ${cacheNames.length} cache(s)</div>`;
                    
                    for (const cacheName of cacheNames) {
                        const cache = await caches.open(cacheName);
                        const keys = await cache.keys();
                        html += `<div class="status info">   - ${cacheName}: ${keys.length} ressources</div>`;
                    }
                } else {
                    html += '<div class="status warning">‚ö†Ô∏è Service Worker non support√©</div>';
                }

                // V√©rifier les donn√©es corrompues
                let corruptedKeys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    try {
                        const value = localStorage.getItem(key);
                        if (value && value.startsWith('{')) {
                            JSON.parse(value);
                        }
                    } catch (e) {
                        corruptedKeys.push(key);
                    }
                }

                if (corruptedKeys.length > 0) {
                    html += `<div class="status error">‚ùå ${corruptedKeys.length} cl√©(s) corrompue(s) d√©tect√©e(s)</div>`;
                    diagnosticData.errors.push(`Corrupted localStorage keys: ${corruptedKeys.join(', ')}`);
                } else {
                    html += '<div class="status success">‚úÖ Aucune donn√©e corrompue d√©tect√©e</div>';
                }

                resultsDiv.innerHTML = html;
                diagnosticData.cacheHealth = { localStorageSize, localStorageItems, cacheNames: cacheNames.length, corruptedKeys };

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur analyse cache : ${error.message}</div>`;
            }
        }

        // 7. Vider tous les caches
        async function clearAllCaches() {
            const resultsDiv = document.getElementById('cache-results');
            
            if (!confirm('‚ö†Ô∏è ATTENTION: Cette action va vider tous les caches et donn√©es locales. Continuer ?')) {
                return;
            }

            resultsDiv.innerHTML = '<div class="status info">üîÑ Nettoyage en cours...</div>';

            try {
                let html = '';

                // Vider localStorage (sauf donn√©es utilisateur importantes)
                const importantKeys = ['userData', 'userLoggedIn'];
                const keysToSave = {};
                
                importantKeys.forEach(key => {
                    const value = localStorage.getItem(key);
                    if (value) keysToSave[key] = value;
                });

                localStorage.clear();
                
                // Restaurer les donn√©es importantes
                Object.entries(keysToSave).forEach(([key, value]) => {
                    localStorage.setItem(key, value);
                });

                html += '<div class="status success">‚úÖ LocalStorage nettoy√© (donn√©es utilisateur pr√©serv√©es)</div>';

                // Vider sessionStorage
                sessionStorage.clear();
                html += '<div class="status success">‚úÖ SessionStorage vid√©</div>';

                // Vider les caches Service Worker
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    for (const cacheName of cacheNames) {
                        await caches.delete(cacheName);
                    }
                    html += `<div class="status success">‚úÖ ${cacheNames.length} cache(s) Service Worker supprim√©(s)</div>`;
                }

                html += '<div class="status success">üéâ Nettoyage termin√© - Actualisez la page</div>';
                resultsDiv.innerHTML = html;
                diagnosticData.fixes.push('Cleared all caches and storage');

                // Proposer de recharger
                setTimeout(() => {
                    if (confirm('Nettoyage termin√©. Recharger la page maintenant ?')) {
                        window.location.reload();
                    }
                }, 2000);

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur nettoyage : ${error.message}</div>`;
            }
        }

        // 8. Mesurer les performances
        async function measurePerformance() {
            const resultsDiv = document.getElementById('performance-results');
            resultsDiv.innerHTML = '<div class="status info">üîÑ Mesure des performances...</div>';

            try {
                let html = '';

                // Navigation Timing
                if (performance.timing) {
                    const timing = performance.timing;
                    const metrics = {
                        'Temps de chargement DOM': timing.domContentLoadedEventEnd - timing.navigationStart,
                        'Temps de chargement complet': timing.loadEventEnd - timing.navigationStart,
                        'Temps de r√©ponse serveur': timing.responseEnd - timing.requestStart
                    };

                    Object.entries(metrics).forEach(([name, value]) => {
                        const status = value < 2000 ? 'success' : value < 5000 ? 'warning' : 'error';
                        const icon = value < 2000 ? '‚úÖ' : value < 5000 ? '‚ö†Ô∏è' : '‚ùå';
                        html += `<div class="status ${status}">${icon} ${name}: ${value}ms</div>`;
                    });

                    diagnosticData.performance = metrics;
                }

                // Memory (si disponible)
                if ('memory' in performance) {
                    const memory = performance.memory;
                    const memoryMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                    const status = memoryMB < 50 ? 'success' : memoryMB < 100 ? 'warning' : 'error';
                    const icon = memoryMB < 50 ? '‚úÖ' : memoryMB < 100 ? '‚ö†Ô∏è' : '‚ùå';
                    html += `<div class="status ${status}">${icon} M√©moire utilis√©e: ${memoryMB}MB</div>`;
                }

                // Taille du bundle (estimation)
                const scripts = document.querySelectorAll('script[src]');
                const styles = document.querySelectorAll('link[rel="stylesheet"]');
                html += `<div class="status info">üì¶ Scripts charg√©s: ${scripts.length}</div>`;
                html += `<div class="status info">üé® Feuilles de style: ${styles.length}</div>`;

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur mesure performance : ${error.message}</div>`;
            }
        }

        // 9. Correction automatique
        async function runAutoFix() {
            const resultsDiv = document.getElementById('auto-fix-results');
            resultsDiv.innerHTML = '<div class="status info">üîß Correction automatique en cours...</div>';

            try {
                let fixes = [];
                let html = '';

                // Fix 1: Nettoyer les donn√©es corrompues
                let corruptedKeys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    try {
                        const value = localStorage.getItem(key);
                        if (value && value.startsWith('{')) {
                            JSON.parse(value);
                        }
                    } catch (e) {
                        corruptedKeys.push(key);
                    }
                }

                if (corruptedKeys.length > 0) {
                    corruptedKeys.forEach(key => localStorage.removeItem(key));
                    fixes.push(`Supprim√© ${corruptedKeys.length} cl√©(s) corrompue(s)`);
                    html += `<div class="status success">‚úÖ ${corruptedKeys.length} donn√©e(s) corrompue(s) supprim√©e(s)</div>`;
                }

                // Fix 2: Nettoyer les caches obsol√®tes
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    const oldCaches = cacheNames.filter(name => !name.includes('v3'));
                    
                    for (const cacheName of oldCaches) {
                        await caches.delete(cacheName);
                    }
                    
                    if (oldCaches.length > 0) {
                        fixes.push(`Supprim√© ${oldCaches.length} cache(s) obsol√®te(s)`);
                        html += `<div class="status success">‚úÖ ${oldCaches.length} cache(s) obsol√®te(s) supprim√©(s)</div>`;
                    }
                }

                // Fix 3: R√©initialiser les param√®tres probl√©matiques
                const problematicKeys = ['temp_', 'cache_', 'debug_'];
                let removedCount = 0;
                
                Object.keys(localStorage).forEach(key => {
                    if (problematicKeys.some(prefix => key.startsWith(prefix))) {
                        localStorage.removeItem(key);
                        removedCount++;
                    }
                });

                if (removedCount > 0) {
                    fixes.push(`Supprim√© ${removedCount} param√®tre(s) temporaire(s)`);
                    html += `<div class="status success">‚úÖ ${removedCount} param√®tre(s) temporaire(s) supprim√©(s)</div>`;
                }

                if (fixes.length === 0) {
                    html = '<div class="status success">‚úÖ Aucune correction n√©cessaire - Le site est en bon √©tat</div>';
                } else {
                    html += `<div class="status success">üéâ ${fixes.length} correction(s) appliqu√©e(s) avec succ√®s</div>`;
                }

                resultsDiv.innerHTML = html;
                diagnosticData.fixes = fixes;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur correction automatique : ${error.message}</div>`;
            }
        }

        // 10. Reset d'urgence
        function emergencyReset() {
            if (!confirm('üö® RESET D\'URGENCE üö®\n\nCette action va :\n- Vider tous les caches\n- Supprimer toutes les donn√©es locales\n- Recharger la page\n\nContinuer ?')) {
                return;
            }

            const resultsDiv = document.getElementById('auto-fix-results');
            resultsDiv.innerHTML = '<div class="status error">üö® Reset d\'urgence en cours...</div>';

            try {
                // Tout nettoyer
                localStorage.clear();
                sessionStorage.clear();
                
                // Nettoyer les caches
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => caches.delete(name));
                    });
                }

                resultsDiv.innerHTML = '<div class="status success">‚úÖ Reset termin√© - Rechargement...</div>';
                
                // Recharger apr√®s un d√©lai
                setTimeout(() => {
                    window.location.href = window.location.origin + '?reset=' + Date.now();
                }, 2000);

            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Erreur reset : ${error.message}</div>`;
            }
        }

        // 11. G√©n√©rer le rapport
        function generateReport() {
            const reportDiv = document.getElementById('final-report');
            
            const report = `
RAPPORT DE DIAGNOSTIC - CERCLE PRIV√â
=====================================

Date: ${new Date().toLocaleString('fr-FR')}
URL: ${window.location.href}
Navigateur: ${navigator.userAgent}

R√âSUM√â:
- Erreurs d√©tect√©es: ${diagnosticData.errors.length}
- Corrections appliqu√©es: ${diagnosticData.fixes.length}
- √âtat g√©n√©ral: ${diagnosticData.errors.length === 0 ? 'BON' : 'PROBL√àMES D√âTECT√âS'}

ERREURS D√âTECT√âES:
${diagnosticData.errors.map((error, i) => `${i+1}. ${error}`).join('\n')}

CORRECTIONS APPLIQU√âES:
${diagnosticData.fixes.map((fix, i) => `${i+1}. ${fix}`).join('\n')}

RECOMMANDATIONS:
${diagnosticData.errors.length === 0 ? 
  '‚úÖ Le site fonctionne correctement' : 
  '‚ö†Ô∏è Contactez le support technique avec ce rapport'
}
            `;

            reportDiv.innerHTML = `<div class="results">${report}</div>`;
        }

        // 12. Exporter pour le support
        function exportReport() {
            const report = JSON.stringify(diagnosticData, null, 2);
            const blob = new Blob([report], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `diagnostic-cercle-prive-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            
            document.getElementById('final-report').innerHTML = 
                '<div class="status success">‚úÖ Rapport export√© - Envoyez ce fichier au support technique</div>';
        }

        // Fonctions utilitaires
        function testLocalStorage() {
            try {
                localStorage.setItem('diagnostic-test', 'test');
                localStorage.removeItem('diagnostic-test');
                return true;
            } catch (e) {
                return false;
            }
        }

        async function checkServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.getRegistration();
                    return !!registration;
                } catch (e) {
                    return false;
                }
            }
            return false;
        }

        // Initialisation automatique
        window.addEventListener('load', () => {
            console.log('üîß Outil de diagnostic charg√©');
            checkGeneralHealth();
        });

        // Capturer les nouvelles erreurs
        window.addEventListener('error', (event) => {
            diagnosticData.errors.push({
                type: 'javascript',
                message: event.error?.message || event.message,
                filename: event.filename,
                lineno: event.lineno,
                timestamp: new Date().toISOString()
            });
        });

        window.addEventListener('unhandledrejection', (event) => {
            diagnosticData.errors.push({
                type: 'promise',
                reason: event.reason?.toString() || 'Unknown rejection',
                timestamp: new Date().toISOString()
            });
        });
    </script>
</body>
</html>